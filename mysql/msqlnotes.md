### mysql必知必会

#### （第一章）了解sql
**数据库（database）** 保存有组织的数据的容器（通常是一个文件或一组文件）。

**数据库（database）** 保存有组织的数据的容器（通常是一个文件或一组文件）。

**模式（schema）** 关于数据库和表的布局及特性的信息。

**列（column）** 表中的一个字段。所有表都是由一个或多个列组成的。

**数据类型（datatype）** 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。

**行（row）** 表中的一个记录。

**主键（primary key）** 一一列（或一组列），其值能够唯一区分表中每个行。

应该总是定义主键 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理。

表中的任何列都可以作为主键，只要它满足以下条件：
- 任意两行都不具有相同的主键值；
- 每个行都必须具有一个主键值（主键列不允许NULL值）。

主键的最好习惯 除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为：
- 不更新主键列中的值；
- 不重用主键列的值；
- 不在主键列中使用可能会更改的值。（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键。）

SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。

#### （第二章）mysql简介
MySQL是一种DBMS，即它是一种数据库软件。
DBMS可分为两类：一类为基于共享文件系统的DBMS，另一类为基于客户机—服务器的DBMS。前者（包括诸如Microsoft Access和FileMaker）用于桌面用途，通常不用于高端或更关键的应用。
MySQL、Oracle以及Microsoft SQL Server等数据库是基于客户机—服务器的数据库。客户机—服务器应用分为两个不同的部分。服务器部分是负责所有数据访问和处理的一个软件。这个软件运行在称为数据库服务器的计算机上。

#### （第三章）使用mysql
为了连接到MySQL，需要以下信息：
- 主机名（计算机名）——如果连接到本地MySQL服务器，为localhost；
- 端口（如果使用默认端口3306之外的端口）；
- 一个合法的用户名；
- 用户口令（如果需要）。
```mysql
mysql -u ben -p -h myserver -P 3306
```

在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用USE关键字。关键字(key word) 作为MySQL语言组成部分的一个保留字。决不要用关键字命名一个表或列。
```mysql
USE mydb;
```

显示可用的数据库：
```mysql
SHOW DATABASES;
```

显示数据库内的可用的表：
```mysql
SHOW TABLES;
```

显示表列：
```mysql
SHOW COLUMNS FROM mydb;
```

- SHOW STATUS，用于显示广泛的服务器状态信息；
- SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创
建特定数据库或表的MySQL语句；
- SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安
全权限；
- SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。

```mysql
HELP SHOW;
```

#### （第四章）检索数据
###### 检索不同的行
就是当检索某列时，去掉重复的要用DISTINCT。
不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。
比如说检索表的某两列，如果某两行的这两列数据完全一样，就会过滤掉其中一行。

<img width="1356" alt="1" src="https://github.com/chamip/languageLearn/assets/42117528/ad881e1b-2af7-4ec6-b801-11bc69eafb76">

<img width="742" alt="2" src="https://github.com/chamip/languageLearn/assets/42117528/20a1d8c5-3629-40a2-9e1e-befa714bcc70">

###### 限制结果
为了返回第一行或前几行，可使用LIMIT子句。
为得出下一个5行，可指定要检索的开始行和行数。第一个数为开始位置，第二个数为要检索的行数。

<img width="711" alt="3" src="https://github.com/chamip/languageLearn/assets/42117528/f06976f0-10b3-441d-815e-6328e556a135">

###### 使用完全限定的表名
就是对列增加表名限定，或对表增加数据库名限定；

#### （第五章）检索排序数据
检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。

**子句（clause）** SQL语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句，我们在前一章看到过这个子句。

`ORDER BY`子句取一个或多个列的名字，据此对输出进行排序。
`DESC`升序
`ASC`降序（ASCENDING）

多个关键字同时使用（比如`ORDER BY`、`LIMIT`）需要注意使用顺序。
`DESC`、`ASC`是跟在列名后并且只对该列生效，需要对多列操作时要分别使用。

#### (第六章)过滤数据
在SELECT语句中，数据根据`WHERE`子句中指定的搜索条件进行过滤。

只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。

WHERE子句的位置 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误

`WHERE`子句操作符
|    op   |   desc  |
| ------- | ------- | 
|    =    |   等于   |
|   <>    |  不等于  |
|   !=    |  不等于  |
|    <    |   小于   |
|   <=    | 小于等于 |
|   >     |   大于   |
|   >=    | 大于等于 |
| BETWEEN | 在指定的两个值之间|

SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。这个WHERE子句就是`IS NULL`子句。

#### （第七章）数据过滤
优先级：圆括号操作符 > AND > OR

`AND` 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。

`OR` `WHERE`子句中使用的关键字，用来表示检索匹配任一给定条件的行。

`IN` `WHERE`子句中用来指定要匹配值的清单的关键字，功能与`OR`相当。

`NOT` `WHERE`子句中用来否定后跟条件的关键字。

`MySQL`中的`NOT` `MySQL`支持使用`NOT`对`IN`、`BETWEEN`和`EXISTS`子句取反，这与多数其他`DBMS`允许使用`NOT`对各种条件取反有很大的差别。

#### （第八章）用通配符进行过滤
`通配符（wildcard）` 
用来匹配值的一部分的特殊字符。

`搜索模式（search pattern）` 
由字面值、通配符或两者组合构成的搜索条件。

**`LIKE`操作符**
为在搜索子句中使用通配符，必须使用LIKE操作符。LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。

**百分号`%`通配符**
最常使用的通配符是百分号（%）。在搜索串中，%表示**任何字符出现任意次数**。

**下划线`_`通配符**
下划线的用途与%一样，但下划线**只匹配单个字符**而不是多个字符。

*注意*：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。

*技巧*：
- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。
- 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。
- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据

#### （第九章）用正则表达式进行搜索
正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。

关键字`REGEXP`

`.`是正则表达式语言中一个特殊的字符。它表示匹配**任意一个字符**。
`LIKE`匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回。
`REGEXP`在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。

`OR`匹配关键字：`|`

匹配几个字符之一：`[]`
字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个`^`即可。

用`-`来定义一个范围。

\或\\? 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。

##### 匹配字符类

| 类         | 说明                                         |
| :--------- | :------------------------------------------- |
| alnum:]    | 任意字母和数字（同[a-zA-Z0-9]）              |
| [:alpha:]  | 任意字符（同[a-zA-Z]）                       |
| [:blank:]  | 空格和制表（同[\t]）                         |
| [:cntrl:]  | ASCII控制字符（ASCII 0到31和127）            |
| [:digit:]  | 任意数字（同[0-9]）                          |
| [:graph:]  | 与[:print:]相同，但不包括空格                |
| [:lower:]  | 任意小写字母（同[a-z]）                      |
| [:print:]  | 任意可打印字符                               |
| [:punct:]  | 既不在[:alnum:]又不在[:cntrl:]中的任意字符   |
| [:space:]  | 包括空格在内的任意空白字符（同[\f\n\r\t\v]） |
| [:upper:]  | 任意大写字母（同[A-Z]）                      |
| [:xdigit:] | 任意十六进制数字（同[a-fA-F0-9]）            |

##### 重复元字符

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| \*     | 0个或多个匹配                |
| +      | 1个或多个匹配（等于{1,}）    |
| ?      | 0个或1个匹配（等于{0,1}）    |
| {n}    | 指定数目的匹配               |
| {n,}   | 不少于指定数目的匹配         |
| {n,m}  | 匹配数目的范围（m不超过255） |

##### 定位符

为了匹配特定位置的文本，需要使用定位符。
| 元字符  | 说明       |
| ------- | ---------- |
| ^       | 文本的开始 |
| $       | 文本的结尾 |
| [[:<:]] | 词的开始   |
| [[:>:]] | 词的结尾   |

*简单的正则表达式测试*
可以在不使用数据库表的情况下用SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配）或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试验它们。相应的语法如下：这个例子显然将返回0（因为文本hello中没有数字）。

#### （第十章）创建计算字段
计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。

计算字段的作用主要是：**拼接字段**、**执行算术计算**

拼接常用的函数有：
- `Concat()`拼接串，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。
- `Trim()`去掉两端多余空格（`RTrim`、`LTrim`）

计算字段常常用到别名（`AS`），方便引用、实际的表列名包含不符合规定的字符（如空格）时重新命名它、在原来的名字含混或容易误解时扩充它。

#### （第十一章）使用数据处理函数
函数没有SQL的可移植性强

大多数SQL实现支持以下类型的函数。
- 用于处理文本串（如删除或填充值，转换值为大写或小写）的**文本函数**。
- 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的**数值函数**。
- 用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的**日期和时间函数**。
- 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的**系统函数**。

###### 文本处理函数
| 函 数       | 说 明             |
| ----------- | ----------------- |
| Left()      | 返回串左边的字符  |
| Length()    | 返回串的长度      |
| Locate()    | 找出串的一个子串  |
| Lower()     | 将串转换为小写    |
| LTrim()     | 去掉串左边的空格  |
| RTrim()     | 去掉串右边的空格  |
| Soundex()   | 返回串的SOUNDEX值 |
| SubString() | 返回子串的字符    |
| Upper()     | 将串转换为大写    |
| Right()     | 返回串右边的字符  |

SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。

eg: 'Y Lee'和'Y Lie'发音相似

<img width="1202" alt="4" src="https://github.com/chamip/languageLearn/assets/42117528/97219bba-aa02-4450-9535-95f7071ab89f">

###### 日期和时间处理函数
日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。

| 函 数         | 说 明                          |
| ------------- | ------------------------------ |
| AddDate()     | 增加一个日期（天、周等）       |
| AddTime()     | 增加一个时间（时、分等）       |
| CurDate()     | 返回当前日期                   |
| CurTime()     | 返回当前时间                   |
| Date()        | 返回日期时间的日期部分         |
| DateDiff()    | 计算两个日期之差               |
| Date_Add()    | 高度灵活的日期运算函数         |
| Date_Format() | 返回一个格式化的日期或时间串   |
| Day()         | 返回一个日期的天数部分         |
| DayOfWeek()   | 对于一个日期，返回对应的星期几 |
| Hour()        | 返回一个时间的小时部分         |
| Minute()      | 返回一个时间的分钟部分         |
| Month()       | 返回一个日期的月份部分         |
| Now()         | 返回当前日期和时间             |
| Second()      | 返回一个时间的秒部分           |
| Time()        | 返回一个日期时间的时间部分     |
| Year()        | 返回一个日期的年份部分         |

**应该总是使用4位数字的年份**
日期必须为格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性

###### 数值处理函数
数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算

| 函 数  | 说 明              |
| ------ | ------------------ |
| Abs()  | 返回一个数的绝对值 |
| Cos()  | 返回一个角度的余弦 |
| Exp()  | 返回一个数的指数值 |
| Mod()  | 返回除操作的余数   |
| Pi()   | 返回圆周率         |
| Rand() | 返回一个随机数     |
| Sin()  | 返回一个角度的正弦 |
| Sqrt() | 返回一个数的平方根 |
| Tan()  | 返回一个角度的正切 |

#### （第十二章）汇总数据
MySQL查询可用于汇总数据，不用把表列实际检索出来，以便分析和报表生成。

`聚集函数（aggregate function）` 运行在行组上，计算和返回单个值的函数。

| 函 数   | 说 明            |
| ------- | ---------------- |
| AVG()   | 返回某列的平均值 |
| COUNT() | 返回某列的行数   |
| MAX()   | 返回某列的最大值 |
| MIN()   | 返回某列的最小值 |
| SUM()   | 返回某列值之和   |

1. `AVG()`通过对表中行数计数并计算特定列值之和，求得该列的平均值。`AVG()`可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。

   `NULL`值 `AVG()`函数忽略列值为`NULL`的行。

4. `COUNT()`函数进行计数。可利用`COUNT()`确定表中行的数目或符合特定条件的行的数目。

   `COUNT()`函数有两种使用方式。
- 使用`COUNT(*)`对表中行的数目进行计数，不管表列中包含的是空值（`NULL`）还是非空值。
- 使用`COUNT(column)`对特定列中具有值的行进行计数，忽略NULL值。

3. `MAX()`返回指定列中的最大值。`MAX()`要求指定列名。

   在用于文本数据时，如果数据按相应的列排序，则`MAX()`返回最后一行。
   `NULL`值 `MAX()`函数忽略列值为`NULL`的行。

5. `MIN()`功能正好与`MAX()`功能相反，它返回指定列的最小值。

6. `SUM()`用来返回指定列值的和（总计）。

   NULL值 SUM()函数忽略列值为NULL的行。

以上5个聚集函数都可以如下使用：
- 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；
- 只包含不同的值，指定DISTINCT参数。

#### （第十三章）分组数据
###### `GROUP BY`子句：`SELECT`语句下，分组数据。

`GROUP BY`子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在`SELECT`中使用表达式，则必须在`GROUP BY`子句中指定相同的表达式。不能使用别名。

`GROUP BY`子句必须出现在`WHERE`子句之后，`ORDER BY`子句之前。

###### `HAVING`子句：过滤分组

目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是`WHERE`过滤**行**，而`HAVING`过滤**分组**。
或者说`WHERE`在数据分组前进行过滤，`HAVING`在数据分组后进行过滤。

`SELECT`子句及其顺序
| 子句     | 说明               | 是否必须使用           |
| -------- | ------------------ | ---------------------- |
| SELECT   | 要返回的列或表达式 | 是                     |
| FROM     | 从中检索数据的表   | 仅在从表选择数据时使用 |
| WHERE    | 行级过滤           | 否                     |
| GROUP BY | 分组说明           | 仅在按组计算聚集时使用 |
| HAVING   | 组级过滤           | 否                     |
| ORDER BY | 输出排序顺序       | 否                     |
| LIMIT    | 要检索的行数       | 否                     |

#### （第十四章）使用子查询
###### WHERE子句的IN操作。
也可以用于测试等于（=）、不等于（<>）等

**列必须匹配** 在`WHERE`子句中使用子查询，应该保证`SELECT`语句具有与`WHERE`子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。

###### 计算字段

**相关子查询（correlated subquery）** 涉及外部查询的子查询。这种类型的子查询称为相关子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。

#### （第十五章）联结表
**关系表** 相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。

好处如下（vendors/products）：
- 供应商信息不重复，从而不浪费时间和空间；
- 如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动；
- 由于数据无重复，显然数据是一致的，这使得处理数据更简单。

**外键（foreign key）** 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。

**可伸缩性（scale）** 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。

分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。

如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？
答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。

**维护引用完整性** 重要的是，要理解联结不是物理实体。换句话说，它在实际的数据库表中不存在。联结由MySQL根据需要建立，它存在于查询的执行当中。

在使用关系表时，仅在关系列中插入合法的数据非常重要。回到这里的例子，如果在products表中插入拥有非法供应商ID（即没有在vendors表中出现）的供应商生产的产品，则这些产品是不可访问的，因为它们没有关联到某个供应商。

为防止这种情况发生，可指示MySQL只允许在products表的供应商ID列中出现合法值（即出现在vendors表中的供应商）。这就是维护引用完整性，它是**通过在表的定义中指定主键和外键来实现的**。

**笛卡儿积（cartesian product）** 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。

**等值联结（equijoin）** 它基于两个表之间的相等测试。这种联结也称为内部联结。(`INNER JOIN ... ON`)

<img width="580" alt="5" src="https://github.com/chamip/languageLearn/assets/42117528/727615a5-ae7f-474a-82ba-814765b0b36c">

#### （第十六章）创建高级联结

**内部联结** 两个表有关联行的联结

**自联结** 在带个`SELECT`语句对同一个表引用不止一次

**自然联结** 无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。

**外部联结** 与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。

#### （第十七章）组合查询
`UNION`操作符将多条SELECT语句组合成一个结果集。组合查询也叫并或复合查询。

有两种基本情况，其中需要使用组合查询：
- 在单个查询中从不同的表返回类似结构的数据；
- 对单个表执行多个查询，按单个查询返回数据。

`UNION`会取消重复的行（它的行为与单个`SELECT`语句中使用多个`WHERE`子句条件相同）。

`UNION ALL`会包含重复的行。

对组合查询排序的话只需在最后一个`SELECT`子句后跟`ORDER BY`。

#### （第十八章）全文本搜索
并非所有引擎都支持全文本搜索，常用的有MyISAM和InnoDB。MyISAM支持全文本搜索，InnoDB不支持。

`LIKE`关键字和正则表达式都是用来匹配文本的，但是存在几个问题：
1. 性能，尝试匹配所有行；
2. 明确控制，很难明确控制匹配什么和不匹配什么；
3. 智能化结果；

`FULLTEXT`给出被索引列的一个逗号分隔的列表。

创建索引之后，使用`Match`和`Against`函数执行全文本搜索，`Match`指定被搜索的列，`Against`指定要使用的搜索表达式。
而且全文本搜索会排序，根据匹配程度。

**查询扩展** 在`Against`函数的表达式后接`WITH QUERY EXPANSION`。
会匹配可能相关的行，比如精确匹配表达式中包含的其他单词。

**布尔文本搜索** 在`Against`函数的搜索表达式后跟`IN BOOLEAN MODE`。
可以指定要匹配的词，排斥的词，排序提示，表达式分组等。

#### （第十九章）插入数据
- 插入完整的行或插入行的一部分

表后可以不跟表列，此时需要按照表列定义的**顺序**提供**所有值**，或者允许填充NULL值（该列允许NULL值，或者表定义默认值）。

表后跟表列，`VALUES`列和指定的列次序对应（更安全，即使表结构变化依然可以正确插入数据），其他列需要满足允许插入NULL值或者有默认值。

- 插入多行

可以使用多条`INSERT`语句，一次提交，每条语句用`;`结束。

或者一条`INSERT`语句，多个`VALUES`后跟多组值。

- 插入某些查询的结果

语法格式：`INSERT INTO tb(col...) SELECT col1... FROM tb1;`

不要求两个表的列名相同，但是数量要对应、主键不冲突。

`LOW_PRIORITY` 当数据检索是主要功能时，可以使用该关键字降低`INSERT`、`UPDATE`、`DELETE`的优先级（跟在`INSERT`后），提高整体性能。

#### （第二十章）更新和删除数据
- 更新

`UPDATE`：更新特定行或所有行。一般需要跟`WHERE`子句指定特定行，否则更新所有行。

语法形式：```UPDATE tb SET col=xxx WEHRE col1=yyy'

`IGNORE`：一般更新多行的时候发生错误整个`UPDATE`操作会取消，发生错误前更新的行会恢复到原来的值，如果希望发生错误继续更新可以使用`UPDATE IGNORE tb...`

若想删除某列的值，可以设置为`NULL`（该列允许控制）

- 删除

`DELETE`：和UPDATE类似。

语法形式：`DELETE FROM tb WHERE col=xxx`

更快的删除整个表的数据（不删除表本身）：`TRUNCATE tb`，实质是删除表本身然后重建。

#### （第二十一章）创建和操纵表
- 创建表

`CREATE TABLE`

1. 表的名字
2. 表列的名字和定义（包括数据类型，是否允许NULL，自增、默认值等）

*如果仅想在表不存在时创建，可以使用`IF NOT EXISTS`，它不检查已有表模式是否与打算创建的表的模式相匹配，只检查表名是否存在，并且仅在表名不存在时创建。*

如果没有指定`NOT NULL`，默认是`NULL`

主键只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识。主键值必须唯一，如果主键使用单个列，它的值必须唯一，如果使用多个列，这些列的组合值必须唯一。

`AUTO_INCREMENT`：只允许一个`AUTO_INCREMENT`列，而且它必须被索引（如，通过使它成为主键）。

引擎类型：
 1. `InnoDB`，可靠的事务处理引擎，不支持全文本搜索
 2. `MEMERY`，功能等同于`MYISAM`，存储在内存，速度很快（适合临时表）
 3. `MYISAM`，性能极高的引擎，支持全文本搜索，不支持事务处理

引擎类型可以混用，但是外键不能跨引擎（即使用一个引擎的表不能引用具有使用不同引擎的表的外键）。

- 更新表

更新表定义，可以使用`ALTER tb`，但是表存储数据后，该表定义不应该被更新。

增加列：`ALTER tb ADD col type`

删除列：`ALTER tb DROP COLUMN col`

定义外键（最常用）：`ALTER tb tb1 ADD CONSTRAINT fk_tb1_tb2 FOREIGN KEY (col) REFERENCES tb2 (col)`

- 删除表

`DROP TABLE tb`

- 重命名表

`RENAME tb1 TO tb2`

